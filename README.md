# java-jungsuk-coding
[도우출판] Java의 정석 전체 소스코드 저장소입니다.



## Chapter 7. 객체지향개념 Ⅱ

### 1. 상속(inheritance)

#### 1.1 상속의 정의와 장점

- 기존의 클래스를 재사용해서 새로운 클래스를 작성하는 것
- 두 클래스를 조상과 자손으로 관계를 맺어주는 것
- 자손은 조상의 모든 멤버를 상속받는다. (생성자, 초기화블럭 제외)
- 자손의 멤버개수는 조상보다 적을 수 없다. (같거나 많다.)

```java
class Point {
    int x, y;
}

class Point3D extends Point { // class 자손클래스 extends 조상클래스
    int z;
}
```

#### 1.2.1 클래스간의 관계 - 상속관계

- 공통부분은 조상에서 관리하고 개별부분은 자손에서 관리한다.
- 조상의 변경은 자손에 영향을 미치지만, 자손의 변경은 조상에 아무런 영향을 미치지 않는다.

#### 1.2.2 클래스관의 관계 - 포함관계(composite)

- 한 클래스의 멤버변수로 다른 클래스를 선언하는 것
- 작은 단위의 클래스를 먼저 만들고, 이 들을 조합해서 하나의 커다란 클래스를 만든다.

```java
class Circle {
    Point c = new Point(); // 원점
    int r; // 반지름(radius)
}
```

#### 1.3 클래스간의 관계결정하기 - 상속 vs 포함

- 가능한 한 많은 관계를 맺어주어 재사용성을 높이고 관리하기 쉽게 한다.
- 'is-a'와 'has-a'를 가지고 문장을 만들어 본다.

```java
상속관계 - '~은 ~이다.(is-a)'				 -> 원(Circle)은 도형(Shape)이다.
포함관계 - '~은 ~을 가지고 있다.(has-a)'	   -> 원(Circle)은 점(Point)을 가지고 있다. 
```

#### 1.4 단일상속(single inheritance)

- Java는 단일상속만을 허용한다.
- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.

#### 1.5 Object 클래스 - 모든 클래스의 최고조상

- 조상이 없는 클래스는 자동적으로 Object 클래스를 상속받게 된다.

- 상속계층도의 최상위에는 Object 클래스가 위치한다.

- 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받는다.

  ex) toString(), equals(Object obj), hashCode(), ...

### 2. 오버라이딩(overriding)

#### 2.1 오버리이딩이란?

- 조상클래스로부터 ```상속받은 메서드의 내용을``` 상속받는 클래스에 맞게 ```변경하는 것```을 오버라이딩이라고 한다.

```java
class Point {
    int x, y;
    
    String getLocation() {
        return "x:" + x + ", y:" + y;
    }
}

class Point3D extends Point {
    int z;
    
    String getLocation() { // 오버라이딩
        return "x:" + x + ", y:" + y + ", z:" + z;
    }
}
```

#### 2.2 오버라이딩의 조건

1. 선언부가 같아야 한다. (이름, 매개변수, 리턴타입)
2. 접근제어자를 좁은 범위로 변경할 수 없다.
   	- 조상의 메서드가 protected라면, 범위가 같거나 넓은 protected나 public으로만 변경할 수 있다.

3. 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

#### 2.3 오버로딩 vs 오버라이딩

- 오버로딩 - 기존에 없는 새로운 메서드를 정의하는 것 (new)
- 오버라이딩 - 상속받은 메서드의 내용을 변경하는 것 (change, modify)

#### 2.4 super - 참조변수

- this - 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어있음

  ​          모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재

- super - this와 같음, 조상의 멤버와 자신의 멤버를 구별하는 데 사용

#### 2.5 super() - 조상의 생성자

  - 자손클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 합쳐진 하나의 인스턴스가 생성된다.

		- 조상의 멤버들도 초기화되어야 하기 때문에 자손의 생성자의 첫 문장에서 조상의 생성자를 호출해야 한다.

### 3. package와 import

#### 3.1 패키지

- 서로 관련된 클래스와 인터페이스의 묶음

- 클래스가 물리적으로 클래스파일(*.class)인 것처럼, 패키지는 물리적으로 폴더이다.

  패키지는 서브패키지를 가질 수 있으며, '.'으로 구분한다.

- 클래스의 실제 이름은 패키지명이 포함된 것이다. (String클래스의 full name은 java.lang.String)

#### 3.2 패키지의 선언

- 패키지는 소스파일에 첫 번째 문장(주석 제외)으로 단 한번 선언한다.

- 하나의 소스파일에 둘 이상의 클래스가 포함된 경우, 모두 같은 패키지에 속하게 된다.

  (하나의 소스파일에 단 하나의 public클래스만 허용한다.)

- 모든 클래스는 하나의 패키지에 속하며, 패키지가 선언되지 않은 클래스는 자동적으로 이름없는(default) 패키지에 속하게 된다.

#### 3.3 클래스패스(classpath) 설정

- 클래스패스는 클래스파일(*.class)를 찾는 경로, 구분자는 ';'

#### 3.4 import문

- 사용할 클래스가 속한 패키지를 지정하는데 사용
- import문을 사용하면 클래스를 사용할 때 패키지명을 생략할 수 있다.

#### 3.5 import문의 선언

- import문은 패키지문과 클래스선언의 사이에 선언한다.
- import문을 선언하는 방법은 다음과 같다.

```java
import 패키지명. 클래스명;
	or
import 패키지명.*;
```

#### 3.6 import문의 선언 - 선언예

- import문은 컴파일 시에 처리되므로 프로그램의 성능에 아무런 영향을 미치지 않는다.
- 이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다.

```java
import java.sql.*;
import java.util.*;
```

### 4. 제어자(modifiers)

#### 4.1 제어자란?

- 클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여한다.
- 제어자는 크게 접근 제어자와 그 외의 제어자로 나뉜다.
- 하나의 대상에 여러 개의 제어자를 조합해서 사용할 수 있으나, 접근제어자는 단 하나만 사용할 수 있다.

```java
접근 제어자 - public, protected, dafault, private
그      외 - static, final, abstract, native, transient, strictfp 등
```

#### 4.2 static - 클래스의, 공통적인

- static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

#### 4.3 final - 마지막의, 변경될 수 없는

- final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

#### 4.4 생성자를 이용한 final 멤버변수 초기화

- final이 붙은 변수는 상수이므로 보통은 선언과 초기화를 동시에 하지만, 인스턴스마다 고정값을 갖는 인스턴스 변수의 경우 생성자에서 초기화한다.

#### 4.5 abstract - 추상의, 미완성의

- abstract가 사용될 수 있는 곳 - 클래스, 메서드

#### 4.6 접근 제어자(access modifier)

- 멤버 또는 클래스에 사용되어, 외부로부터의 접근을 제한한다.

|  제어자   | 같은 클래스 | 같은 패키지 | 자손클래스 | 전체 |
| :-------: | :---------: | :---------: | :--------: | :--: |
|  public   |      O      |      O      |     O      |  O   |
| protected |      O      |      O      |     O      |      |
|  default  |      O      |      O      |            |      |
|  private  |      O      |             |            |      |

#### 4.7 접근 제어자를 이용한 캡슐화

- 접근 제어자를 사용하는 이유
  1. 외부로부터 데이터를 보호하기 위해서
  2. 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

#### 4.8 생성자의 접근 제어자

- 일반적으로 생성자의 접근 제어자는 클래스의 접근 제어자와 일치한다.
- 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.

#### 4.9 제어자의 조합

|   대상   |             사용가능한 제어자             |
| :------: | :---------------------------------------: |
|  클래스  |    public, (default), final, abstract     |
|  메서드  | 모든 접근 제어자, final, abstract, static |
| 멤버변수 |      모든 접근 제어자, final, static      |
| 지역변수 |                   final                   |

### 5. 다형성(polymorphism)

#### 5.1 다형성이란?

- "여러 가지 형태를 가질 수 있는 능력"

- "하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것"

  즉, 조상타입의 참조변수로 자손타입의 객체를 다룰 수 있는 것이 다형성

```java
Tv t = new Tv(); // 부모
CaptionTv c = new CaptionTv(); // 자식

Tv t = new CaptionTv(); 
```

- "조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있지만,

   반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다."

#### 5.2 참조변수의 형변환

- 서로 상속관계에 있는 타입간의 형변환만 가능하다.
- 자손 타입에서 조상타입으로 형변환하는 경우, 형변환 생략가능

```java
자손타입 -> 조상타입 (Up-casting)   : 형변환 생략가능
자손타입 <- 조상타입 (Down-casting) : 형변환 생략불가
```

#### 5.3 instanceof 연산자

- 참조변수가 참조하는 인스턴스의 실제 타입을 체크하는데 사용
- 이항연산자이며 피연산자는 참조형 변수와 타입, 연산결과는 true/false
- instanceof의 연산결과가 true이면, 해당 타입으로 형변환이 가능하다.

#### 5.4 참조변수와 인스턴스변수의 연결

- 멤버변수가 중복정의된 경우, 참조변수의 타입에 따라 연결되는 멤버변수가 달라진다. (참조변수타입에 영향받음)
- 메서드가 중복정의된 경우, 참조변수의 타입에 관계없이 항상 실제 인스턴스의 타입에 정의된 메서드가 호출된다. (참조변수타입에 영향받지 않음)

#### 5.5 매개변수의 다형성

- 참조형 매개변수는 메서드 호출시, ```자신과 같은 타입 또는 자손타입```의 인스턴스를 넘겨줄 수 있다.

#### 5.6 여러 종류의 객체를 하나의 배열로 다루기

- 조상타입의 배열에 자손들의 객체를 담을 수 있다.

```java
Product p[] = new Product[3];
p[0] = new Tv();
p[1] = new Computer();
p[2] = new Audio();
```

## Chapter 7. 객체지향개념 Ⅲ

### 6. 추상클래스(abstract class)

#### 6.1 추상클래스란?

- 클래스가 설계도라면 추상클래스는 '미완성 설계도'
- 추상메서드(미완성 메서드)를 포함하고 있는 클래스
  - 추상메서드 : 선언부만 있고 구현부(몸통, body)가 없는 메서드

```java
abstract class Player {
    int currentPos; 			 // 현재 Play되고 있는 위치를 저장하기 위한 변수
    Player() {					 // 추상클래스도 생성자가 있어야 한다.
        currentPos = 0;
    }
    
    abstract void play(int pos); // 추상메서드
    abstract void stop();        // 추상메서드
    
    void play() {
        play(currentPos);        // 추상메서드를 사용할 수 있다.
    }
}
```

- 일반메서드가 추상메서드를 호출할 수 있다. (호출할 때 필요한 건 선언부)
- 완성된 설계도가 아니므로 인스턴스를 생성할 수 없다.
- 다른 클래스를 작성하는 데 도움을 줄 목적으로 작성된다.
- 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 사용
- 추상클래스를 상속받는 자손클래스에서 추상메서드의 구현부를 완성해야 한다.

#### 6.2 추상클래스의 작성

- 여러 클래스에 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나 기존클래스의 공통 부분을 뽑아서 추상클래스를 만든다.

### 7. 인터페이스(interface)

#### 7.1 인터페이스란?

- 일종의 추상클래스, 추상클래스(일종의 설계도)보다 추상화 정도가 높다.
- 실제 구현된 것이 전혀 없는 기본 설계도 (알맹이 없는 껍데기)
- 추상메서드와 상수만을 멤버로 가질 수 있다.
- 인스턴스를 생성할 수 없고, 클래스 작성에 도움을 줄 목적으로 사용된다.
- 미리 정해진 규칙에 맞게 구현하도록 표준을 제시하는데 사용된다.
